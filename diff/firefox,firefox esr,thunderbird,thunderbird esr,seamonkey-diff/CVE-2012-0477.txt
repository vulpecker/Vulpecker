diff --git a/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp b/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp
--- a/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp
+++ b/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp
@@ -100,106 +100,106 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
   while ((src < srcEnd))
   {
     switch (mState)
     {
       case eState_ASCII:
         if(ESC == *src) {
            mState = eState_ESC;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_ESC:    // ESC
         if('$' == *src) {
            mState = eState_ESC_24;
         } else {
-           if(dest+2 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 2))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_ESC_24: // ESC $
         if(')' == *src) {
            mState = eState_ESC_24_29;
         } else if('*' == *src) {
            mState = eState_ESC_24_2A;
         } else if('+' == *src) {
            mState = eState_ESC_24_2B;
         } else {
-           if(dest+3 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 3))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_ESC_24_29: // ESC $ )
         if('A' == *src) {
            mState = eState_ESC_24_29_A;
         } else if('G' == *src) {
            mState = eState_ESC_24_29_G;
         } else {
-           if(dest+4 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 4))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) ')';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_ESC_24_29_A:  // ESC $ ) A
         if(SO == *src) {
            mState = eState_GB2312_1980;
            mRunLength = 0;
         } else {
-           if(dest+5 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 5))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) ')';
            *dest++ = (PRUnichar) 'A';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_GB2312_1980:   // ESC $ ) A SO
         if(SI == *src) { // Shift-In (SI)
            mState = eState_ESC_24_29_A_SO_SI;
            if (mRunLength == 0) {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = 0xFFFD;
            }
            mRunLength = 0;
         } else if(ESC == *src) {
            mState = eState_ESC;
         } else {
            if(0x20 < *src && *src < 0x7f) {
               mData = *src;
               mState = eState_GB2312_1980_2ndbyte;
            } else {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
            }
         }
         break; 
 
       case eState_GB2312_1980_2ndbyte:  // ESC $ ) A SO
         if(0x20 < *src && *src < 0x7f) {
@@ -215,73 +215,73 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
            if(rv == NS_OK_UDEC_MOREOUTPUT) {
               goto error1;
            } else if(NS_FAILED(rv)) {
               goto error2;
            }
 
            dest += aLen;
         } else {
-           if(dest+2 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 2))
               goto error1;
            *dest++ = (PRUnichar) mData;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
         }
         mState = eState_GB2312_1980;
         break;
 
       case eState_ESC_24_29_A_SO_SI:  // ESC $ ) A SO SI
         if(SO == *src) {
            mState = eState_GB2312_1980;
            mRunLength = 0;
         } else if(ESC == *src) {
            mState = eState_ESC;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ESC_24_29_A_SO_SI;
         }
         break;
 
       case eState_ESC_24_29_G:   // ESC $ ) G
         if(SO == *src) {
            mState = eState_CNS11643_1;
            mRunLength = 0;
         } else {
-           if(dest+5 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 5))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) ')';
            *dest++ = (PRUnichar) 'G';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_CNS11643_1:   // ESC $ ) G SO
         if(SI == *src) { // Shift-In (SI)
            mState = eState_ESC_24_29_G_SO_SI;
            if (mRunLength == 0) {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = 0xFFFD;
            }
            mRunLength = 0;
         } else if(ESC == *src) {
            mState = eState_ESC;
         } else {
            if(0x20 < *src && *src < 0x7f) {
               mData = *src;
               mState = eState_CNS11643_1_2ndbyte;
            } else {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
            }
         }
         break;
 
       case eState_CNS11643_1_2ndbyte:  // ESC $ ) G SO
         if(0x20 < *src && *src < 0x7f) {
@@ -297,59 +297,59 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
            if(rv == NS_OK_UDEC_MOREOUTPUT) {
               goto error1;
            } else if(NS_FAILED(rv)) {
               goto error2;
            }
 
            dest += aLen;
         } else {
-           if(dest+2 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 2))
               goto error1;
            *dest++ = (PRUnichar) mData;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
         }
         mState = eState_CNS11643_1;
         break;
 
       case eState_ESC_24_29_G_SO_SI: // ESC $ ) G SO SI
         if(SO == *src) {
            mState = eState_CNS11643_1;
            mRunLength = 0;
         } else if(ESC == *src) {
            mState = eState_ESC;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ESC_24_29_G_SO_SI;
         }
         break;
 
       case eState_ESC_24_2A: // ESC $ *
         if('H' == *src) {
            mState = eState_ESC_24_2A_H;
         } else {
-           if(dest+4 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 4))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) '*';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_ESC_24_2A_H:  // ESC $ * H
         if(ESC == *src) {
            mState = eState_ESC_24_2A_H_ESC;
         } else {
-           if(dest+5 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 5))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) '*';
            *dest++ = (PRUnichar) 'H';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
@@ -358,46 +358,46 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
 
       case eState_ESC_24_2A_H_ESC:  // ESC $ * H ESC
         if(SS2 == *src) {
            mState = eState_CNS11643_2;
            mRunLength = 0;
         } else if('$' == *src) {
            mState = eState_ESC_24;
         } else {
-           if(dest+6 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 6))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) '*';
            *dest++ = (PRUnichar) 'H';
            *dest++ = (PRUnichar) ESC;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_CNS11643_2:  // ESC $ * H ESC SS2
         if(SI == *src) { // Shift-In (SI)
            mState = eState_ESC_24_2A_H_ESC_SS2_SI;
            if (mRunLength == 0) {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = 0xFFFD;
            }
            mRunLength = 0;
         } else if(ESC == *src) {
            mState = eState_ESC_24_2A_H_ESC;
         } else {
            if(0x20 < *src && *src < 0x7f) {
               mData = *src;
               mState = eState_CNS11643_2_2ndbyte;
            } else {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
            }
         }
         break;
 
       case eState_CNS11643_2_2ndbyte:   // ESC $ * H ESC SS2
         if(0x20 < *src && *src < 0x7f) {
@@ -415,72 +415,72 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
            if(rv == NS_OK_UDEC_MOREOUTPUT) {
               goto error1;
            } else if(NS_FAILED(rv)) {
               goto error2;
            }
 
            dest += aLen;
         } else {
-           if(dest+2 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 2))
               goto error1;
            *dest++ = (PRUnichar) mData;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
         }
         mState = eState_CNS11643_2;
         break;
 
       case eState_ESC_24_2A_H_ESC_SS2_SI:  // ESC $ * H ESC SS2 SI
         if(ESC == *src) {
            mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ESC_24_2A_H_ESC_SS2_SI;
         }
         break;
 
       case eState_ESC_24_2A_H_ESC_SS2_SI_ESC:  // ESC $ * H ESC SS2 SI ESC
         if(SS2 == *src) {
            mState = eState_CNS11643_2;
            mRunLength = 0;
         } else if('$' == *src) {
            mState = eState_ESC_24;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ESC_24_2A_H_ESC_SS2_SI;
         }
         break;
 
       case eState_ESC_24_2B: // ESC $ +
         if('I' <= *src && *src <= 'M') {
             mState = eState_ESC_24_2B_I;
             mPlaneID = *src - 'I' + 3;
         } else {
-           if(dest+4 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 4))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) '+';
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_ESC_24_2B_I:  // ESC $ + I
         if(ESC == *src) {
            mState = eState_ESC_24_2B_I_ESC;
         } else {
-           if(dest+5 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 5))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) '+';
            *dest++ = (PRUnichar) 'I' + mPlaneID - 3;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
@@ -489,46 +489,46 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
 
       case eState_ESC_24_2B_I_ESC:  // ESC $ + I ESC
         if(SS3 == *src) {
            mState = eState_CNS11643_3;
            mRunLength = 0;
         } else if('$' == *src) {
            mState = eState_ESC_24;
         } else {
-           if(dest+6 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 6))
               goto error1;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (PRUnichar) '$';
            *dest++ = (PRUnichar) '+';
            *dest++ = (PRUnichar) 'I' + mPlaneID - 3;
            *dest++ = (PRUnichar) ESC;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ASCII;
         }
         break;
 
       case eState_CNS11643_3:   // ESC $ + I ESC SS3
         if(SI == *src) { // Shift-In (SI)
            mState = eState_ESC_24_2B_I_ESC_SS3_SI;
            if (mRunLength == 0) {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = 0xFFFD;
            }
            mRunLength = 0;
         } else if(ESC == *src) {
            mState = eState_ESC_24_2B_I_ESC;
         } else {
            if(0x20 < *src && *src < 0x7f) {
               mData = *src;
               mState = eState_CNS11643_3_2ndbyte;
            } else {
-              if(dest+1 >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 1))
                  goto error1;
               *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
            }
         }
 
         break;
 
       case eState_CNS11643_3_2ndbyte:  // ESC $ + I ESC SS3
@@ -547,44 +547,44 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
            if(rv == NS_OK_UDEC_MOREOUTPUT) {
               goto error1;
            } else if(NS_FAILED(rv)) {
               goto error2;
            }
 
            dest += aLen;
         } else {
-           if(dest+2 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 2))
               goto error1;
            *dest++ = (PRUnichar) mData;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
         }
         mState = eState_CNS11643_3;
         break;
 
       case eState_ESC_24_2B_I_ESC_SS3_SI:  // ESC $ + I ESC SS3 SI
         if(ESC == *src) {
            mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ESC_24_2B_I_ESC_SS3_SI;
         }
         break;
 
       case eState_ESC_24_2B_I_ESC_SS3_SI_ESC:  // ESC $ + I ESC SS3 SI ESC
         if(SS3 == *src) {
            mState = eState_CNS11643_3;
            mRunLength = 0;
         } else if('$' == *src) {
            mState = eState_ESC_24;
         } else {
-           if(dest+1 >= destEnd)
+           if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
            *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
 
            mState = eState_ESC_24_2B_I_ESC_SS3_SI;
         }
         break;
 
       case eState_ERROR:
@@ -595,20 +595,16 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Conv
     src++;
   }
 
   *aDestLen = dest- aDest;
   return NS_OK;
 
 error1:
   *aDestLen = dest-aDest;
-  src++;
-  if ((mState == eState_ASCII) && (src == srcEnd)) {
-    return NS_OK;
-  }
   *aSrcLen = src - (const unsigned char*)aSrc;
   return NS_OK_UDEC_MOREOUTPUT;
 
 error2:
   *aSrcLen = src - (const unsigned char*)aSrc;
   *aDestLen = dest-aDest;
   mState = eState_ASCII;
   return NS_ERROR_UNEXPECTED;
diff --git a/intl/uconv/ucvja/nsJapaneseToUnicode.cpp b/intl/uconv/ucvja/nsJapaneseToUnicode.cpp
--- a/intl/uconv/ucvja/nsJapaneseToUnicode.cpp
+++ b/intl/uconv/ucvja/nsJapaneseToUnicode.cpp
@@ -500,66 +500,66 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
           case mState_ASCII:
             if(0x1b == *src)
             {
               mLastLegalState = mState;
               mState = mState_ESC;
             } else if(*src & 0x80) {
               goto error2;
             } else {
+              if (CHECK_OVERRUN(dest, destEnd, 1))
+                goto error1;
               *dest++ = (PRUnichar) *src;
-              if(dest >= destEnd)
-                goto error1;
             }
           break;
           
           case mState_ESC:
             if( '(' == *src) {
               mState = mState_ESC_28;
             } else if ('$' == *src)  {
               mState = mState_ESC_24;
             } else if ('.' == *src)  { // for ISO-2022-JP-2
               mState = mState_ESC_2e;
             } else if ('N' == *src)  { // for ISO-2022-JP-2
               mState = mState_ESC_4e;
             } else  {
-              if((dest+2) >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 2))
                 goto error1;
               *dest++ = (PRUnichar) 0x1b;
               if(0x80 & *src)
                 goto error2;
               *dest++ = (PRUnichar) *src;
               mState = mLastLegalState;
             }
           break;
 
           case mState_ESC_28: // ESC (
             if( 'B' == *src) {
               mState = mState_ASCII;
               if (mRunLength == 0) {
-                if((dest+1) >= destEnd)
+                if (CHECK_OVERRUN(dest, destEnd, 1))
                   goto error1;
                 *dest++ = 0xFFFD;
               }
               mRunLength = 0;
             } else if ('J' == *src)  {
               mState = mState_JISX0201_1976Roman;
               if (mRunLength == 0 && mLastLegalState != mState_ASCII) {
-                if((dest+1) >= destEnd)
+                if (CHECK_OVERRUN(dest, destEnd, 1))
                   goto error1;
                 if (mErrBehavior == kOnError_Signal)
                   goto error2;
                 *dest++ = 0xFFFD;
               }
               mRunLength = 0;
             } else if ('I' == *src)  {
               mState = mState_JISX0201_1976Kana;
               mRunLength = 0;
             } else  {
-              if((dest+3) >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 3))
                 goto error1;
               *dest++ = (PRUnichar) 0x1b;
               *dest++ = (PRUnichar) '(';
               if(0x80 & *src)
                 goto error2;
               *dest++ = (PRUnichar) *src;
               mState = mLastLegalState;
             }
@@ -573,17 +573,17 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
               mState = mState_GB2312_1980;
               mRunLength = 0;
             } else if ('B' == *src)  {
               mState = mState_JISX0208_1983;
               mRunLength = 0;
             } else if ('(' == *src)  {
               mState = mState_ESC_24_28;
             } else  {
-              if((dest+3) >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 3))
                 goto error1;
               *dest++ = (PRUnichar) 0x1b;
               *dest++ = (PRUnichar) '$';
               if(0x80 & *src)
                 goto error2;
               *dest++ = (PRUnichar) *src;
               mState = mLastLegalState;
             }
@@ -592,17 +592,17 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
           case mState_ESC_24_28: // ESC $ (
             if( 'C' == *src) {
               mState = mState_KSC5601_1987;
               mRunLength = 0;
             } else if ('D' == *src) {
               mState = mState_JISX0212_1990;
               mRunLength = 0;
             } else  {
-              if((dest+4) >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 4))
                 goto error1;
               *dest++ = (PRUnichar) 0x1b;
               *dest++ = (PRUnichar) '$';
               *dest++ = (PRUnichar) '(';
               if(0x80 & *src)
                 goto error2;
               *dest++ = (PRUnichar) *src;
               mState = mLastLegalState;
@@ -614,36 +614,36 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
               mLastLegalState = mState;
               mState = mState_ESC;
             } else if(*src & 0x80) {
               goto error2;
             } else {
               // XXX We need to  decide how to handle \ and ~ here
               // we may need a if statement here for '\' and '~' 
               // to map them to Yen and Overbar
+              if (CHECK_OVERRUN(dest, destEnd, 1))
+                goto error1;
               *dest++ = (PRUnichar) *src;
               ++mRunLength;
-              if(dest >= destEnd)
-                goto error1;
             }
           break;
 
           case mState_JISX0201_1976Kana:
             if(0x1b == *src) {
               mLastLegalState = mState;
               mState = mState_ESC;
             } else {
               if((0x21 <= *src) && (*src <= 0x5F)) {
+                if (CHECK_OVERRUN(dest, destEnd, 1))
+                  goto error1;
                 *dest++ = (0xFF61-0x0021) + *src;
                 ++mRunLength;
               } else {
                 goto error2;
               }
-              if(dest >= destEnd)
-                goto error1;
             }
           break;
 
           case mState_JISX0208_1978:
             if(0x1b == *src) {
               mLastLegalState = mState;
               mState = mState_ESC;
             } else if(*src & 0x80) {
@@ -720,22 +720,22 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
           case mState_JISX0208_1978_2ndbyte:
           {
             PRUint8 off = sbIdx[*src];
             if(0xFF == off) {
                goto error2;
             } else {
                // XXX We need to map from JIS X 0208 1983 to 1987 
                // in the next line before pass to *dest++
-               *dest++ = gJapaneseMap[mData+off];
-               ++mRunLength;
+              if (CHECK_OVERRUN(dest, destEnd, 1))
+                goto error1;
+              *dest++ = gJapaneseMap[mData+off];
+              ++mRunLength;
             }
             mState = mState_JISX0208_1978;
-            if(dest >= destEnd)
-              goto error1;
           }
           break;
 
           case mState_GB2312_1980_2ndbyte:
           {
             PRUint8 off = sbIdx[*src];
             if(0xFF == off) {
                goto error2;
@@ -747,49 +747,49 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
                          do_GetService(kCharsetConverterManagerCID, &rv);
                 if (NS_SUCCEEDED(rv)) {
                   rv = ccm->GetUnicodeDecoderRaw("GB2312", &mGB2312Decoder);
                 }
               }
               if (!mGB2312Decoder) {// failed creating a delegate converter
                 goto error2;
               } else {
+                if (CHECK_OVERRUN(dest, destEnd, 1))
+                  goto error1;
                 unsigned char gb[2];
                 PRUnichar uni;
                 PRInt32 gbLen = 2, uniLen = 1;
                 // ((mData/94)+0x21) is the original 1st byte.
                 // *src is the present 2nd byte.
                 // Put 2 bytes (one character) to gb[] with GB2312 encoding.
                 gb[0] = ((mData / 94) + 0x21) | 0x80;
                 gb[1] = *src | 0x80;
                 // Convert GB2312 to unicode.
                 mGB2312Decoder->Convert((const char *)gb, &gbLen,
                                         &uni, &uniLen);
                 *dest++ = uni;
                 ++mRunLength;
               }
             }
             mState = mState_GB2312_1980;
-            if(dest >= destEnd)
-              goto error1;
           }
           break;
 
           case mState_JISX0208_1983_2ndbyte:
           {
             PRUint8 off = sbIdx[*src];
             if(0xFF == off) {
                goto error2;
             } else {
-               *dest++ = gJapaneseMap[mData+off];
-               ++mRunLength;
+              if (CHECK_OVERRUN(dest, destEnd, 1))
+                goto error1;
+              *dest++ = gJapaneseMap[mData+off];
+              ++mRunLength;
             }
             mState = mState_JISX0208_1983;
-            if(dest >= destEnd)
-              goto error1;
           }
           break;
 
           case mState_KSC5601_1987_2ndbyte:
           {
             PRUint8 off = sbIdx[*src];
             if(0xFF == off) {
                goto error2;
@@ -801,109 +801,111 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
                          do_GetService(kCharsetConverterManagerCID, &rv);
                 if (NS_SUCCEEDED(rv)) {
                   rv = ccm->GetUnicodeDecoderRaw("EUC-KR", &mEUCKRDecoder);
                 }
               }
               if (!mEUCKRDecoder) {// failed creating a delegate converter
                 goto error2;
               } else {              
+                if (CHECK_OVERRUN(dest, destEnd, 1))
+                  goto error1;
                 unsigned char ksc[2];
                 PRUnichar uni;
                 PRInt32 kscLen = 2, uniLen = 1;
                 // ((mData/94)+0x21) is the original 1st byte.
                 // *src is the present 2nd byte.
                 // Put 2 bytes (one character) to ksc[] with EUC-KR encoding.
                 ksc[0] = ((mData / 94) + 0x21) | 0x80;
                 ksc[1] = *src | 0x80;
                 // Convert EUC-KR to unicode.
                 mEUCKRDecoder->Convert((const char *)ksc, &kscLen,
                                        &uni, &uniLen);
                 *dest++ = uni;
                 ++mRunLength;
               }
             }
             mState = mState_KSC5601_1987;
-            if(dest >= destEnd)
-              goto error1;
           }
           break;
 
           case mState_JISX0212_1990_2ndbyte:
           {
             PRUint8 off = sbIdx[*src];
             if(0xFF == off) {
                goto error2;
             } else {
-               *dest++ = gJapaneseMap[mData+off];
-               ++mRunLength;
+              if (CHECK_OVERRUN(dest, destEnd, 1))
+                goto error1;
+              *dest++ = gJapaneseMap[mData+off];
+              ++mRunLength;
             }
             mState = mState_JISX0212_1990;
-            if(dest >= destEnd)
-              goto error1;
           }
           break;
 
           case mState_ESC_2e: // ESC .
             // "ESC ." will designate 96 character set to G2.
             mState = mLastLegalState;
             if( 'A' == *src) {
               G2charset = G2_ISO88591;
             } else if ('F' == *src) {
               G2charset = G2_ISO88597;
             } else  {
-              if((dest+3) >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 3))
                 goto error1;
               *dest++ = (PRUnichar) 0x1b;
               *dest++ = (PRUnichar) '.';
               if(0x80 & *src)
                 goto error2;
               *dest++ = (PRUnichar) *src;
             }
           break;
 
           case mState_ESC_4e: // ESC N
             // "ESC N" is the SS2 sequence, that invoke a G2 designated
             // character set.  Since SS2 is effective only for next one
             // character, mState should be returned to the last status.
             mState = mLastLegalState;
             if((0x20 <= *src) && (*src <= 0x7F)) {
               if (G2_ISO88591 == G2charset) {
+                if (CHECK_OVERRUN(dest, destEnd, 1))
+                  goto error1;
                 *dest++ = *src | 0x80;
                 ++mRunLength;
               } else if (G2_ISO88597 == G2charset) {
                 if (!mISO88597Decoder) {
                   // creating a delegate converter (ISO-8859-7)
                   nsresult rv;
                   nsCOMPtr<nsICharsetConverterManager> ccm = 
                            do_GetService(kCharsetConverterManagerCID, &rv);
                   if (NS_SUCCEEDED(rv)) {
                     rv = ccm->GetUnicodeDecoderRaw("ISO-8859-7", &mISO88597Decoder);
                   }
                 }
                 if (!mISO88597Decoder) {// failed creating a delegate converter
                   goto error2;
                 } else {
+                  if (CHECK_OVERRUN(dest, destEnd, 1))
+                    goto error1;
                   // Put one character with ISO-8859-7 encoding.
                   unsigned char gr = *src | 0x80;
                   PRUnichar uni;
                   PRInt32 grLen = 1, uniLen = 1;
                   // Convert ISO-8859-7 to unicode.
                   mISO88597Decoder->Convert((const char *)&gr, &grLen,
                                             &uni, &uniLen);
                   *dest++ = uni;
                   ++mRunLength;
                 }
               } else {// G2charset is G2_unknown (not designated yet)
                 goto error2;
               }
-              if(dest >= destEnd)
-                goto error1;
             } else {
-              if((dest+3) >= destEnd)
+              if (CHECK_OVERRUN(dest, destEnd, 3))
                 goto error1;
               *dest++ = (PRUnichar) 0x1b;
               *dest++ = (PRUnichar) 'N';
               if(0x80 & *src)
                 goto error2;
               *dest++ = (PRUnichar) *src;
             }
           break;
@@ -916,19 +918,15 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Co
 
        } // switch
        src++;
    }
    *aDestLen = dest - aDest;
    return NS_OK;
 error1:
    *aDestLen = dest - aDest;
-   src++;
-   if ((mState == 0) && (src == srcEnd)) {
-     return NS_OK;
-   }
    *aSrcLen = src - (const unsigned char*)aSrc;
    return NS_OK_UDEC_MOREOUTPUT;
 error2:
    *aSrcLen = src - (const unsigned char*)aSrc;
    *aDestLen = dest - aDest;
    return NS_ERROR_UNEXPECTED;
 }
diff --git a/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp b/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp
--- a/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp
+++ b/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp
@@ -66,62 +66,62 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Conv
         // fall through
 
       case mState_ASCII:
         if(0x0e == *src) { // Shift-Out 
           mState = mState_KSX1001_1992;
           mRunLength = 0;
         } 
         else if(*src & 0x80) {
+          if (CHECK_OVERRUN(dest, destEnd, 1))
+            goto error1;
           *dest++ = 0xFFFD;
-          if(dest >= destEnd)
-            goto error1;
         } 
         else {
+          if (CHECK_OVERRUN(dest, destEnd, 1))
+            goto error1;
           *dest++ = (PRUnichar) *src;
-          if(dest >= destEnd)
-            goto error1;
         }
         break;
           
       case mState_ESC:
         if('$' == *src) {
           mState = mState_ESC_24;
         } 
         else  {
-          if((dest+2) >= destEnd)
+          if (CHECK_OVERRUN(dest, destEnd, 2))
             goto error1;
           *dest++ = (PRUnichar) 0x1b;
           *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
           mState =  mLastLegalState;
         }
         break;
 
       case mState_ESC_24: // ESC $
         if(')' == *src) {
           mState = mState_ESC_24_29;
         } 
         else  {
-          if((dest+3) >= destEnd)
+          if (CHECK_OVERRUN(dest, destEnd, 3))
             goto error1;
           *dest++ = (PRUnichar) 0x1b;
           *dest++ = (PRUnichar) '$';
           *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
           mState = mLastLegalState;
         }
         break;
 
       case mState_ESC_24_29: // ESC $ )
         mState = mLastLegalState;
         if('C' == *src) {
           mState = mState_ASCII;
           mRunLength = 0;
         } 
         else  {
-          if((dest+4) >= destEnd)
+          if (CHECK_OVERRUN(dest, destEnd, 4))
             goto error1;
           *dest++ = (PRUnichar) 0x1b;
           *dest++ = (PRUnichar) '$';
           *dest++ = (PRUnichar) ')';
           *dest++ = (0x80 & *src) ? 0xFFFD : (PRUnichar) *src;
           mState = mLastLegalState;
         }
         break;
@@ -129,34 +129,34 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Conv
       case mState_KSX1001_1992:
         if (0x20 < (PRUint8) *src  && (PRUint8) *src < 0x7f) {
           mData = (PRUint8) *src;
           mState = mState_KSX1001_1992_2ndbyte;
         } 
         else if (0x0f == *src) { // Shift-In (SI)
           mState = mState_ASCII;
           if (mRunLength == 0) {
-            if(dest+1 >= destEnd)
+            if (CHECK_OVERRUN(dest, destEnd, 1))
               goto error1;
             *dest++ = 0xFFFD;
           }
           mRunLength = 0;
         } 
         else if ((PRUint8) *src == 0x20 || (PRUint8) *src == 0x09) {
           // Allow space and tab between SO and SI (i.e. in Hangul segment)
+          if (CHECK_OVERRUN(dest, destEnd, 1))
+            goto error1;
           mState = mState_KSX1001_1992;
           *dest++ = (PRUnichar) *src;
           ++mRunLength;
-          if(dest >= destEnd)
-          goto error1;
         } 
         else {         // Everything else is invalid.
+          if (CHECK_OVERRUN(dest, destEnd, 1))
+            goto error1;
           *dest++ = 0xFFFD;
-          if(dest >= destEnd)
-             goto error1;
         }
         break;
 
       case mState_KSX1001_1992_2ndbyte:
         if ( 0x20 < (PRUint8) *src && (PRUint8) *src < 0x7f  ) {
           if (!mEUCKRDecoder) {
             // creating a delegate converter (EUC-KR)
             nsresult rv;
@@ -166,51 +166,51 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Conv
               rv = ccm->GetUnicodeDecoderRaw("EUC-KR", &mEUCKRDecoder);
             }
           }
 
           if (!mEUCKRDecoder) {// failed creating a delegate converter
            *dest++ = 0xFFFD;
           } 
           else {              
+            if (CHECK_OVERRUN(dest, destEnd, 1))
+              goto error1;
             unsigned char ksx[2];
             PRUnichar uni;
             PRInt32 ksxLen = 2, uniLen = 1;
             // mData is the original 1st byte.
             // *src is the present 2nd byte.
             // Put 2 bytes (one character) to ksx[] with EUC-KR encoding.
             ksx[0] = mData | 0x80;
             ksx[1] = *src | 0x80;
             // Convert EUC-KR to unicode.
             mEUCKRDecoder->Convert((const char *)ksx, &ksxLen, &uni, &uniLen);
             *dest++ = uni;
             ++mRunLength;
           }
-          if(dest >= destEnd)
-            goto error1;
           mState = mState_KSX1001_1992;
         } 
         else {        // Invalid 
           if ( 0x0f == *src ) {   // Shift-In (SI)
             mState = mState_ASCII;
           } 
           else {
             mState = mState_KSX1001_1992;
           }
+          if (CHECK_OVERRUN(dest, destEnd, 1))
+            goto error1;
           *dest++ = 0xFFFD;
-          if(dest >= destEnd)
-           goto error1;
         }
         break;
 
       case mState_ERROR:
         mState = mLastLegalState;
+        if (CHECK_OVERRUN(dest, destEnd, 1))
+          goto error1;
         *dest++ = 0xFFFD;
-        if(dest >= destEnd)
-          goto error1;
         break;
 
     } // switch
     src++;
   }
   *aDestLen = dest - aDest;
   return NS_OK;
 
diff --git a/intl/uconv/util/nsUCSupport.h b/intl/uconv/util/nsUCSupport.h
--- a/intl/uconv/util/nsUCSupport.h
+++ b/intl/uconv/util/nsUCSupport.h
@@ -40,16 +40,17 @@
 
 #include "nsCOMPtr.h"
 #include "nsIUnicodeEncoder.h"
 #include "nsIUnicodeDecoder.h"
 #include "uconvutil.h"
 #include "mozilla/Mutex.h"
 
 #define ONE_BYTE_TABLE_SIZE 256
+#define CHECK_OVERRUN(dest, destEnd, length) ((dest > destEnd) || ((destEnd - dest) < length))
 
 #ifdef NS_DEBUG
 // {7AFC9F0A-CFE1-44ea-A755-E3B86AB1226E}
 #define NS_IBASICDECODER_IID \
 { 0x7afc9f0a, 0xcfe1, 0x44ea, { 0xa7, 0x55, 0xe3, 0xb8, 0x6a, 0xb1, 0x22, 0x6e } }
 
 // {65968A7B-6467-4c4a-B50A-3E0C97A32F07}
 #define NS_IBASICENCODER_IID \

