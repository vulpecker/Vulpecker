diff --git a/js/src/jsarray.cpp b/js/src/jsarray.cpp
--- a/js/src/jsarray.cpp
+++ b/js/src/jsarray.cpp
@@ -1713,17 +1713,17 @@ InitArrayElements(JSContext *cx, JSObjec
         return JS_FALSE;
 
     JS_ASSERT(start == MAXINDEX);
     jsval tmp[2] = {JSVAL_NULL, JSVAL_NULL};
     jsdouble* dp = js_NewWeaklyRootedDouble(cx, MAXINDEX);
     if (!dp)
         return JS_FALSE;
     tmp[0] = DOUBLE_TO_JSVAL(dp);
-    JSAutoTempValueRooter(cx, JS_ARRAY_LENGTH(tmp), tmp);
+    JSAutoTempValueRooter tvr(cx, JS_ARRAY_LENGTH(tmp), tmp);
     JSAutoTempIdRooter idr(cx);
     do {
         tmp[1] = *vector++;
         if (!js_ValueToStringId(cx, tmp[0], idr.addr()) ||
             !obj->setProperty(cx, idr.id(), &tmp[1])) {
             return JS_FALSE;
         }
         *dp += 1;
diff --git a/js/src/json.cpp b/js/src/json.cpp
--- a/js/src/json.cpp
+++ b/js/src/json.cpp
@@ -101,17 +101,17 @@ JSClass js_JSONClass = {
 };
 
 JSBool
 js_json_parse(JSContext *cx, uintN argc, jsval *vp)
 {
     JSString *s = NULL;
     jsval *argv = vp + 2;
     jsval reviver = JSVAL_NULL;
-    JSAutoTempValueRooter(cx, 1, &reviver);
+    JSAutoTempValueRooter tvr(cx, 1, &reviver);
 
     if (!JS_ConvertArguments(cx, argc, argv, "S / v", &s, &reviver))
         return JS_FALSE;
 
     JSONParser *jp = js_BeginJSONParse(cx, vp);
     JSBool ok = jp != NULL;
     if (ok) {
         const jschar *chars;
@@ -125,18 +125,18 @@ js_json_parse(JSContext *cx, uintN argc,
 }
 
 JSBool
 js_json_stringify(JSContext *cx, uintN argc, jsval *vp)
 {
     jsval *argv = vp + 2;
     JSObject *replacer = NULL;
     jsval space = JSVAL_NULL;
-    JSAutoTempValueRooter(cx, replacer);
-    JSAutoTempValueRooter(cx, 1, &space);
+    JSAutoTempValueRooter tvr(cx, replacer);
+    JSAutoTempValueRooter tvr2(cx, 1, &space);
 
     // Must throw an Error if there isn't a first arg
     if (!JS_ConvertArguments(cx, argc, argv, "v / o v", vp, &replacer, &space))
         return JS_FALSE;
 
     JSCharBuffer cb(cx);
 
     if (!js_Stringify(cx, vp, replacer, space, cb))
